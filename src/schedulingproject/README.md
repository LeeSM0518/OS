# 스케줄링 알고리즘 프로젝트

## 구현 사항

* **스케줄러**
  * 총 처리 시간 = 총 버스트 시간
  * 평균 대기 시간 = 대기 시간 - 도착 시간
  * 도착 시간 (0, 1, ...)
  * 프로세스 개수 선택
  * 랜덤으로 버스트 시간, 우선 순위 할당

* **선입 선처리 스케줄링, FCFS(First-Come, First-Served)**

  * CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는다.
  * 비선점

* **최단 작업 우선 스케줄링, SJF(Shortest-Job)**

  * CPU가 이용 가능해지면, 다음 CPU 버스트가 가장 짧은 프로세스에게 할당
  * 비선점

* **최소 잔여시간 우선 스케줄링, SRTF(Shortest Remaining Time First)**

  * 새로운 프로세스가 현재 실행되고 있는 프로세스의 남은 시간보다 짧은 버스트를 가지면 현재 실행중인 프로세스를 선점한다.
  * 선점

* **우선 순위 스케줄링**

  * 우선 순위 랜덤 할당 필요
  * 우선 순위가 각 프로세스에게 주어지고 CPU는 가장 높은 우선 순위를 가진 프로세스에 할당된다.
  * 선점, 비선점

* **라운드 로빈 스케줄링, RR(Round-Robin)**

  * 스케줄러는 준비완료 큐를 돌아가면서 한번에 한 프로세스에 시간 할당량만큼 CPU를 할당한다.

* **다단계 큐 스케줄링**

  * 포그라운드 큐와 백그라운드 큐로 나뉜다.
  * 포그라운드 큐는 RR 알고리즘에 의해 스케줄링 되며, 백그라운드 큐는 선입 선처리 알고리즘에 의해 처리된다.
  * 프로세스의 특성에 따라 포그라운드 큐나 백그라운드 큐로 할당된다.
  * 우선 순위: 포그라운드 > 백그라운드

* **다단계 피드백 큐 스케줄링**

  * 큐가 3개가 존재하고, 첫 번째 큐는 8밀리 초의 시간 할당량이 주어지는데 이 시간 안에 끝나지 않는다면 큐 1의 꼬리로 이동된다. 큐0이 비어 있다면, 큐 1의 머리에 있는 프로세스에게 16밀리초의 시간 할당량이 주어진다. 이 프로세스가 완료되지 않는다면, 선입선처리 큐로 보낸다.
  * 라운드로빈, 선입선처리 쓰임

  * 우선 순위: 큐0 > 큐1 > 큐2

<br>

## UI

* 첫화면

  ```
  ================================
  CPU 스케줄링
  프로세스 개수를 입력해주세요.
  ================================
  ```

* 메인 화면

  ```
  ================================
  CPU 스케줄링
  
  프로세스 도착시간 우선순위 버스트시간
  1      0      2      3
  2      1      4      6
  
  스케줄링을 선택해주세요.
  1. 선입선처리 (비선점)
  2. 최단 작업 우선 (비선점)
  3. 최소 잔여시간 우선 (선점)
  4. 우선 순위 (비선점)
  5. 우선 순위 (선점)
  6. 라운드 로빈 (비선점)
  7. 다단계 큐
  8. 다단계 피드백 큐
  9. 이전으로
  10. 종료하기
  ================================
  ```

* 스케줄링 선택 후

  ```
  ================================
  CPU 스케줄링
  
  프로세스 대기시간
  1      0
  2      3
  
  총 처리 시간: 11
  평균 대기 시간: 13
  ================================
  ```

<br>

## 클래스 다이어그램

![image](https://user-images.githubusercontent.com/43431081/75090927-311d6500-55ab-11ea-8f2d-c0fcdb98e773.png)

