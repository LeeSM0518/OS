# CHAPTER 1. 서론

* **운영체제(operating system)**
  * 컴퓨터 하드웨어를 관리하는 프로그램이다.
  * 응용 프로그램을 위한 기반을 제공
  * 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할
  * Windows 는 일반인들이 사용하기에 편리하도록 설계된 운영체제, Linux는 효율성에 주안들 두고 설계된 운영체제

<br>

# 1.1. 운영체제가 할 일

전체 컴퓨터 시스템에서 운영체제가 수행하는 역할을 살펴보자.

<br>

**컴퓨터 시스템의 구성요소**

* **하드웨어**
  * 중앙 처리 장치(CPU)
  * 메모리
  * 입출력(I/O) 장치
* **운영체제**
  * 사용자를 위해 응용 프로그램간의 하드웨어 사용을 제어하고 조정
* **응용 프로그램**
  * 워드 프로세서, 컴파일러, 웹 브라우저 등
* **사용자**

<img src="../capture/스크린샷 2020-01-02 오후 1.41.00.png">

> 즉, OS는 응용 프로그램이 하드웨어를 적절히 사용하여 유용한 작업을 할 수 있는 환경을 제공해주는 것이다.

운영체제의 역할을 자세히 이해하기 위해서 사용자와 시스템 두 관점을 살펴보자.

<br>

## 1.1.1. 사용자 관점(User View)

* **개인 컴퓨터 (사용자가 한명)**
  * 이러한 경우의 운영체제는 대부분 사용의 용이성을 위해 설계
  * 성능에 약간 신경쓰고 하드웨어와 소프트웨어 자원 이용에는 신경을 쓰지 않는다.
* **대형 컴퓨터(mainframe)** : 금융 거래 처리(대용량 데이터 처리), 다수의 사용자
  * 이 경우 운영체제는 자원 이용을 극대화하도록 설계
  * CPU, 메모리, 입출력을 효율적으로 사용
* **슈퍼 컴퓨터** => 대형 컴퓨터보다 한단계 높고 초고속으로 복잡한 계산(원자력 개발)

> 따라서 사용자 관점으로써의 운영체제는 개인의 사용 용이성과 자원 이용 간의 적절한 조화이다.

<br>

## 1.1.2. 시스템 관점(System View)

운영체제는 하드웨어와 가장 밀접하게 연관된 프로그램이기 때문에 운영체제를 **자원 할당자(resource allocator)로** 볼 수 있다. 운영체제는 컴퓨터 시스템을 효율적이고 공정하게 운영할 수 있도록 적절한 자원 할당이 관건이다.

또한, 운영체제는 사용자의 부적절한 사용(내부 하드웨어 자원을 함부로 막 사용하는)을 방지하기 위해 사용자 프로그램의 수행을 제어하는 **제어 프로그램(control program)** 이기도 하다.

> 따라서 시스템 관점으로써의 운영체제는 하드웨어 자원을 할당해주고 사용자의 부적절한 사용을 제어해주는 프로그램이다.

<br>

## 1.1.3. 운영체제의 정의

1. 사용자의 문제 발생 (사람이 직접 계산하지 않고 기계가 필요해짐)
2. 하드웨어 제작
3. 순수 하드웨어만으로는 사용하기 어려움으로 응용 프로그램 개발
4. 다양한 프로그램들에서 입출력 장치의 통제와 같은 공통적인 연산을 필요로 해서 **자원을 제어하고 할당하는 공통 연산 기능을 하나의 소프트웨어로 통합한 것이 운영체제이다.**

<br>

운영체제는 어느 부분이 운영체제에 속하고 어느 부분이 속하지 않는 지에 대한 보편적으로 인정되는 정의가 존재하지 않는다. 예를 들면 윈도우는 사용자 인터페이스를 운영체제의 일부로 여기는데 리눅스는 그렇지 않다.

운영체제는 컴퓨터에서 항상 수행되는 프로그램으로 일반적으로 **커널이라** 불린다.

커널은 운영 체제의 핵심이 되는 컴퓨터 프로그램의 하나이다. 커널은 모든 컴퓨터 하드웨어 장치에 대한 가장 기초 수준의 제어권을 제공한다.

<br>

# 1.2. 컴퓨터 시스템의 구성

## 1.2.1. 컴퓨터 시스템 연산(Computer-System Operation)

<img src="../capture/스크린샷 2020-01-02 오후 4.24.17.png">

* 현대의 범용 컴퓨터 시스템은 공유 메모리에 대한 접근을 제공하는 공통 버스에 의해 연결된 여러 개의 장치 제어기와 하나 이상의 CPU로 구성된다.
* CPU와 장치 제어기는 메모리 사이클을 얻기 위해 경쟁하면서 병렬 수행된다.
* 메모리 제어기는 메모리 접근을 동기화 시킨다. 즉, 질서 있는 접근을 보장한다.

<br>

**컴퓨터 구동 시작 과정**

1. 읽기 전용 메모리(ROM, Read-Only Memory)나 EEPROM에 저장되어 있는 소프트웨어인 펌웨어(부트스트랩)가 CPU 레지스터로부터, 장치 제어기, 메모리 내용 등을 포함한 모든 시스템을 초기화한다.
   * **ROM, EEPROM** : 이 메모리들은 전원이 없어도 펌웨어 같은 수행 초기 프로그램을 갖고 있어야하므로 비휘발성 메모리이다. (ex: 아두이노 메모리)
   * **CPU 레지스터** : CPU 내부에서 처리할 명령어나 중간 결과값 등을 일시적으로 기억하는 임시 기억장소
2. 부트스트랩(펌웨어) 프로그램은 운영체제의 커널을 찾아 메모리에 적재한다.
3. 커널이 적재되면 시스템과 사용자에게 서비스 제공

<br>

일부 서비스는 커널이 아닌 시스템 프로그램에 의해 제공되는데 이들은 부트 시에 메모리에 적재되어 커널이 수행되는 동안 계속 수행되는 **시스템 프로세스(프로그램 자체와 실행 작업 단위)나 시스템 디먼(데몬: 백그라운드에서 도는 프로그램)이** 된다.

<br>

완전히 부트가 되면 시스템은 무슨 사건(event)가 발생하기를 기다린다.

사건이 발생하면 하드웨어나 소프트웨어가 **인터럽트(interrupt, CPU에게 사건 처리 요청)를** 발생시킨다.

* 하드웨어는 언제든 인터럽트를 발생시킬 수 있다.
* 소프트웨어는 **시스템 호출(system call)을 통해** 인터럽트를 발생시킨다.

<br>

<img src="../capture/스크린샷 2020-01-02 오후 8.08.38.png">

* CPU가 사용자 프로세스를 실행하고 있는데 입/출력 장치로 부터 입/출력 요구 인터럽트가 발생하면 CPU는 하던 일을 중단하고 입/출력 인터럽트를 처리하는 **인터럽트 서비스 루틴(인터럽트가 발생하면 실행할 내용)이** 실행된다.
* 서비스 루틴이 종료되면 CPU는 다시 이전에 처리하던 연산을 재개한다.

<br>

인터럽트는 적절한 서비스 루틴으로 제어를 전달한다. 

전달된 루틴을 처리하는 방식은 루틴을 호출하는 방법이다. 이 루틴은 인터럽트 고유의 핸들러를 호출한다.

* 사용 가능한 인터럽트의 수가 정의되어 있으므로 인터럽트 루틴의 주소를 가리키는 포인터들의 테이블을 이용할 수 있다.
* 이 테이블을 통하여 간접적으로 루틴이 호출된다.

결국 인터럽트가 요청되면 **인터럽트 벡터(인터럽트 루틴의 주소 배열)가** 인터럽트 요청과 함께 유일한 장치 번호로 색인된다.

<br>

또한, 인터럽트는 원래 처리하고 있던 명령의 주소를 반드시 저장해야 한다. 왜냐하면 루틴을 처리한 뒤 다시 이전에 처리하던 연산으로 재개해야 하기 때문이다.

* 예전 방식 : 고정 위치에 인터럽트 주소 저장
* 최근 방식 : 시스템 스택에 복귀 주소 저장

<br>

### 저장장치 정의와 표기

* **비트** : 컴퓨터 저장장치의 기본단위는 비트이며 0, 1 두 값 중 하나를 가진다.
* **바이트** : 컴퓨터에서 가장 작은 편리한 저장장치 조작

컴퓨터 저장장치는 대부분 바이트 단위 및 바이트의 집합을 단위로 조작된다.

ex) 1KB (1024), 1MB(1024^2^), 1GB(1024^3^), 1TB(1024^4^), 1PB(1024^5^)

<br>

## 1.2.2. 저장 장치 구조 (Storage Structure)

CPU는 명령어를 메모리부터 가져올 수 있기 때문에 프로그램은 반드시 메모리에 올라와 있어야 한다.

프로그램은 보통 **주 메모리(Random-Access Memory)에** 올라 간다.

* RAM(휘발성)은 **Dynamic Random-Access Memory(DRAM)라** 불리는 반도체 기술로 구현된다.
* ROM, EEPROM(비휘발성)은 펌웨어 같은 정적 프로그램을 저장한다.

<br>

모든 메모리는 바이트 형식으로 자신의 주소를 가지고 있다.

메모리와 CPU의 상호작용은 적재(load) 또는 저장(store) 명령을 통해 이루어진다.

* **적재(load)** : RAM으로부터 CPU 내부의 레지스터로 옮기는 것
* **저장(store)** : CPU 레지스터 내용을 RAM으로 옮기는 것

CPU는 실행을 위해 자동적으로 주 메모리로부터 명령을 적재한다.

<br>

**폰 노이만 구조** 시스템에서 실행되는 전형적인 명령-실행 사이클은 먼저 메모리로부터 명령을 인출해, 그 명령을 **명령 레지스터(RAM으로부터 읽어온 명령어를 기억하는 CPU 내부의 레지스터)에** 저장한다. 그 후 명령을 해독하고 실행한 뒤 결과를 다시 메모리에 저장한다.

<br>

우리는 RAM이 영구히 데이터를 유지해주기를 원하지만 하지만 이건 불가능하다.

* RAM은 데이터를 영구히 저장하기에는 너무 작다.
* RAM은 전원이 공급되지 않으면 내용을 잃어버리는 휘발성 장치이다.

그러므로 RAM의 확장으로 **보조 저장 장치를** 사용해야 한다.

**보조 저장 장치(하드디스크)는** 대량의 데이터를 영구히 보존할 수 있다.

<br>

지금까지 우리는 저장 장치 시스템 중 RAM(주 메모리), ROM, EEPROM(읽기 전용 메모리), Disk(보조 저장 장치)를 봤는데 이외에도 캐시 메모리, CD, 테이프 등 매우 다양하다.

이것들의 주된 차이점은 **속도, 가격, 크기, 휘발성** 이다.

<img src="../capture/스크린샷 2020-01-02 오후 9.27.57.png">

* 아래로 갈수록 비트당 비용은 감소하며, 접근 시간을 증가한다.
* 반도체 디스크 위의 저장 시스템은 휘발성이고 반도체 디스크부터 그 아래는 비휘발성이다.
  * **반도체 디스크** 중에 하나는 갑자기 외부 전원이 중단되면, RAM으로 부터 반도체 자기 디스크로 복사하고 전원이 복원되면, 디스크에 있는 데이터를 RAM으로 복사.
  * 다른 형태로는 플래시 메모리(아두이노)가 있다.

<br>

## 1.2.3. 입출력 구조(I/O Structure)

* 저장 장치는 여러 입출력 장치 중의 하나이다.

* 범용 컴퓨터 시스템은 여러 개의 장치 제어기와 CPU들로 구성된다.

* 장치 제어기는 로컬 버퍼 저장 장치와 특수 목적용 레지스터 집합을 유지한다.

* 장치 제어기는 제어하는 장치와 자신의 저장 장치 사이의 데이터 전송을 담당한다.
* 운영체제는 장치 제어기의 동작을 이해하고 장치에 대한 인터페이스를 제공하는 디바이스 드라이버를 가지고 있다.
* 디바이스 드라이버는 장치 제어기의 적절한 레지스터에 필요한 값을 적재하여 입출력 연산을 준비한다.
* 장치 제어기는 장치의 요청(키보드가 눌림)을 처리하기 위해 레지스터의 내용을 조사.
* 제어기는 장치로부터 자신의 로컬 버퍼로 데이터 전송
* 장치 제어기는 인터럽트를 이용해 디바이스 드라이버에게 연산 완료를 통보
* 디바이스 드라이버는 제어를 운영체제에게 반환

<br>

위와 같은 인터럽트 구동 방식은 디스크 입출력과 같은 대량의 데이터를 전송할때는 오버헤드를 초래한다.

이 문제를 해결하기 위해서는 **직접 메모리 접근(DMA) 장치가** 사용된다. DMA를 통해 장치 제어기가 전송 작업을 수행하고 있는 동안 CPU는 다른 작업을 수행할 수 있기 때문에 효율적이다.

<img src="../capture/스크린샷 2020-01-02 오후 9.54.23.png">

<br>

# 1.3. 컴퓨터 시스템 구조 (Computer-System Architecture)

컴퓨터 시스템은 범용 처리기(CPU) 수에 따라 다양한 방식으로 구성될 수 있다.

<br>

## 1.3.1. 단일 처리기 시스템(Single-Processor Systems)

* 단일 처리기 시스템은 사용자 프로세스, 범용 명령어 집합을 수행하는 하나의 주 CPU를 갖는다.
* 또한 디스크나 키보드 등을 제어하는 특수 목적 전용 처리기도 갖는다. 이 처리기들은 운영체제와 독립적으로 자신의 작업을 처리한다.

<br>

## 1.3.2. 다중 처리기 시스템(Multiprocessor Systems)

다중 처리기 시스템은 하나 이상의 처리기들을 가지며 처리기들 끼리 컴퓨터 버스, 클락, 메모리, 주변 장치를 공유한다.

<img src="../capture/스크린샷 2020-01-02 오후 10.41.27.png">

<br>

**다중 처리기 시스템은 주요 장점**

1. **증가된 처리량** : 다수의 처리기가 하나의 태스크를 협력해서 처리하므로 처리량이 증가한다. 하지만 N개의 처리량 만큼은 N배되지 않는다. 왜냐하면 협력을 통한 정확한 처리를 하기 위해서 약간의 오버헤드가 발생되기 때문이다.
2. **규모의 경제** : 여러 개의 단일 시스템에 비해 비용을 절약할 수 있다. 왜냐하면 주변ㅈ 장치, 저장 장치 등을 처리기끼리 공유하기 때문이다.
3. **증가된 신뢰성** : 기능들이 여러 개의 처리기에 적절히 분산된다면 한 처리기가 고장나더라도 시스템이 정지하지 않는다.

한 하드웨어가 고장이 나더라도 나머지 하드웨어로 계속적인 서비스를 제공하는 능력을 **우아한 퇴보** 라고 한다.

시스템이 어느 한 구성요소의 고장에도 불구하고 동작을 계속할 수 있으면 **결함 허용** 이라고 부른다.

<br>

현재 사용되고 있는 다중 처리기 시스템은 두 가지 형태를 가진다.

1. 각 처리기에 특정 태스크가 할당되는 **비대칭적 다중 처리** 
   * 주 처리기는 작업을 스케줄하고 종속 처리기에 작업을 할당(주종 관계)
2. 각 처리기가 운영체제 내의 모든 작업을 수행하는 **대칭적 다중 처리(SMP: Symmetric multiprocessing)**
   * 모든 처리기가 대등하다.
   * 모든 처리기는 메모리를 공유한다.
   * 이러한 형태의 다중 처리기 시스템은 다수의 처리기 간에 프로세스와 자원이 동적으로 공유되게 해야하고 처리기 간의 불균형을 줄여야만 비효율을 막을 수 있다.

<br>

하나의 CPU에 여러 개의 **코어(core)를** 포함시킨 다중 처리기 시스템을 **멀티코어라** 부른다.

칩 내의 통신이 CPU와의 통신보다 빠르기 때문에 전력을 훨씬 덜 소모한다.

<img src="../capture/스크린샷 2020-01-02 오후 10.42.11.png">

<br>

## 1.3.3. 클러스터형 시스템(Clustered Systems)

클러스터: 군체, 무리